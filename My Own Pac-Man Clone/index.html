<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Basic reset and body styling */
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* Prevent scrollbars */
        }

        /* Game container styling */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            border: 8px solid #333;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
            padding: 20px;
            margin: 20px;
            box-sizing: border-box;
            position: relative; /* For message box positioning */
        }

        /* Game title */
        h1 {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00, 0 0 20px #ffcc00;
            margin-bottom: 20px;
            font-size: 2em;
            text-align: center;
        }

        /* Score and Lives display */
        #score, #lives {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        #lives {
            color: #ff0000; /* Red for lives */
            text-shadow: 0 0 5px #ff0000;
        }

        /* Canvas styling */
        canvas {
            background-color: #000;
            display: block;
            border: 2px solid #0000ff;
            box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);
            border-radius: 5px;
            touch-action: none; /* Disable default touch actions */
        }

        /* Game controls container */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
        }

        /* Directional buttons */
        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            width: 150px;
            height: 150px;
            margin-top: 10px;
        }

        .d-pad button {
            background-color: #444;
            color: #fff;
            border: 2px solid #666;
            border-radius: 8px;
            font-size: 1.2em;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
        }

        .d-pad button:hover {
            background-color: #666;
            transform: translateY(-2px);
        }

        .d-pad button:active {
            background-color: #222;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Specific button positioning for D-pad */
        .d-pad .up { grid-column: 2; grid-row: 1; }
        .d-pad .left { grid-column: 1; grid-row: 2; }
        .d-pad .right { grid-column: 3; grid-row: 2; }
        .d-pad .down { grid-column: 2; grid-row: 3; }
        .d-pad .center { grid-column: 2; grid-row: 2; visibility: hidden; } /* Placeholder */

        /* Message box styling */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 5px solid #ffff00;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .message-box p {
            font-size: 1.8em;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #fff;
        }

        .message-box button {
            background-color: #00ff00;
            color: #000;
            border: none;
            border-radius: 8px;
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
            font-family: 'Press Start 2P', cursive;
        }

        .message-box button:hover {
            background-color: #00cc00;
            transform: translateY(-2px);
        }

        .message-box button:active {
            background-color: #009900;
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.5em;
            }
            #score, #lives {
                font-size: 1.2em;
            }
            .game-container {
                padding: 15px;
                margin: 10px;
                width: calc(100% - 20px); /* Adjust width for smaller screens */
            }
            canvas {
                width: 100%; /* Make canvas fill container width */
                height: auto; /* Maintain aspect ratio */
            }
            .message-box p {
                font-size: 1.2em;
            }
            .message-box button {
                padding: 10px 20px;
                font-size: 1em;
            }
            .d-pad {
                width: 120px;
                height: 120px;
            }
            .d-pad button {
                font-size: 1em;
                padding: 8px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.2em;
            }
            #score, #lives {
                font-size: 1em;
            }
            .game-container {
                padding: 10px;
                margin: 5px;
            }
            .message-box p {
                font-size: 1em;
            }
            .message-box button {
                padding: 8px 15px;
                font-size: 0.9em;
            }
            .d-pad {
                width: 100px;
                height: 100px;
            }
            .d-pad button {
                font-size: 0.8em;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>PAC-MAN</h1>
        <div id="score">SCORE: 0</div>
        <div id="lives">LIVES: 3</div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <p>Use Arrow Keys or D-Pad to move</p>
            <div class="d-pad">
                <button class="up" id="upButton">⬆️</button>
                <button class="left" id="leftButton">⬅️</button>
                <div class="center"></div>
                <button class="right" id="rightButton">➡️</button>
                <button class="down" id="downButton">⬇️</button>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageButton">OK</button>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Configuration Constants ---
        const TILE_SIZE = 20; // Size of each tile in the grid
        const PACMAN_RADIUS = TILE_SIZE / 2 - 2; // Pac-Man's radius
        const GHOST_RADIUS = TILE_SIZE / 2 - 2; // Ghost's radius
        const PELLET_RADIUS = 2; // Pellet's radius
        const POWER_PELLET_RADIUS = 5; // Power pellet's radius
        const PACMAN_SPEED = 2; // Pixels per frame
        const GHOST_SPEED = 1.5; // Pixels per frame
        const POWER_PELLET_DURATION = 8000; // Power pellet effect duration in ms
        const DEATH_ANIMATION_DURATION = 1200; // 1.2 seconds for the animation

        // --- Maze Generation Constants ---
        const MAZE_LOGICAL_WIDTH = 10; // Number of "cells" wide for maze generation
        const MAZE_LOGICAL_HEIGHT = 10; // Number of "cells" high for maze generation
        const MAP_WIDTH_TILES = MAZE_LOGICAL_WIDTH * 2 + 1;
        const MAP_HEIGHT_TILES = MAZE_LOGICAL_HEIGHT * 2 + 1;

        // --- Bonus Food Constants ---
        const BONUS_FOOD_DURATION = 9000; // Bonus food stays visible for 9 seconds
        const BONUS_FOOD_SPAWN_INTERVALS = [70, 170]; // First bonus at 70 pellets, second at 170 pellets
        const bonusFoodData = [
            { type: 'cherry', value: 100 },
            { type: 'strawberry', value: 200 },
            { type: 'orange', value: 500 },
            { type: 'apple', value: 700 },
            { type: 'melon', value: 1000 },
            { type: 'galaxian', value: 2000 },
            { type: 'bell', value: 3000 },
            { type: 'key', value: 5000 }
        ];

        // --- Game State Variables ---
        let gameState = 'title'; // 'title', 'playing', 'cutscene', 'gameOver'
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameRunning = false; // Flag for active game logic updates
        let animationFrameId; // To store the requestAnimationFrame ID
        let gameMap; // The 2D array representing the current maze

        // --- Pac-Man Object ---
        let pacman = {
            x: 0, y: 0,
            dx: 0, dy: 0,
            nextDx: 0, nextDy: 0,
            angle: 0,
            mouthOpen: 0,
            mouthDirection: 1,
            isPoweredUp: false,
            powerUpTimer: null,
            isDying: false,
            deathStartTime: 0
        };

        // --- Ghost Objects (Initial properties; positions set in resetGame) ---
        let ghosts = [
            { id: 'blinky', color: 'red', state: 'leavingHouse' },
            { id: 'pinky', color: 'pink', state: 'leavingHouse' },
            { id: 'inky', color: 'cyan', state: 'leavingHouse' },
            { id: 'clyde', color: 'orange', state: 'leavingHouse' },
            { id: 'sue', color: 'purple', state: 'leavingHouse' }
        ];

        // --- Ghost House Coordinates (determined dynamically in resetGame) ---
        let ghostHouseStartCol = 0;
        let ghostHouseStartRow = 0;
        let entranceX = 0;
        let entranceY = 0;
        let GHOST_HOUSE_EXIT_PIXEL_X = 0;
        let GHOST_HOUSE_EXIT_PIXEL_Y = 0;

        // --- Bonus Food State Variables ---
        let bonusFoodActive = false;
        let bonusFoodX = 0;
        let bonusFoodY = 0;
        let bonusFoodType = '';
        let bonusFoodValue = 0;
        let bonusFoodDespawnTime = 0;
        let pelletsEatenCount = 0;
        let bonusFoodSpawnedThisLevel = 0;

        // --- Score Pop-up for Bonus Food ---
        let scorePopup = {
            active: false,
            x: 0, y: 0,
            value: 0,
            startTime: 0,
            duration: 1000
        };

        // --- Cutscene Management ---
        let currentCutscene = {
            id: null,
            scenes: [],
            currentSceneIndex: 0,
            sceneStartTime: 0
        };

        // Define your cutscenes here
        const cutscenes = {
            level_1_complete: [
                {
                    duration: 2000,
                    draw: (ctx, progress) => {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.font = '24px "Press Start 2P"';
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'center';
                        ctx.fillText('Level 1 Complete!', canvas.width / 2, 50);

                        const pacmanSize = PACMAN_RADIUS * 1.5;
                        const ghostSize = GHOST_RADIUS * 1.5;
                        const startX = 50;
                        const endX = canvas.width / 2 - 50;
                        const currentPacmanX = startX + progress * (endX - startX);
                        const currentBlinkyX = currentPacmanX + (1 - progress) * 80 + 30;

                        // Draw Pac-Man (simplified)
                        ctx.fillStyle = 'yellow';
                        ctx.beginPath();
                        ctx.arc(currentPacmanX, canvas.height / 2, pacmanSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw Blinky (simplified)
                        ctx.fillStyle = 'red';
                        ctx.beginPath();
                        ctx.arc(currentBlinkyX, canvas.height / 2, ghostSize, Math.PI, 0, false);
                        ctx.lineTo(currentBlinkyX - ghostSize, canvas.height / 2 + ghostSize);
                        ctx.lineTo(currentBlinkyX + ghostSize, canvas.height / 2 + ghostSize);
                        ctx.closePath();
                        ctx.fill();
                        // Blinky's eyes (static)
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(currentBlinkyX - ghostSize / 2.5, canvas.height / 2 - ghostSize / 3, ghostSize / 4, 0, Math.PI * 2);
                        ctx.arc(currentBlinkyX + ghostSize / 2.5, canvas.height / 2 - ghostSize / 3, ghostSize / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(currentBlinkyX - ghostSize / 2.5, canvas.height / 2 - ghostSize / 3, ghostSize / 8, 0, Math.PI * 2);
                        ctx.arc(currentBlinkyX + ghostSize / 2.5, canvas.height / 2 - ghostSize / 3, ghostSize / 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                },
                {
                    duration: 1500,
                    draw: (ctx, progress) => {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.font = '24px "Press Start 2P"';
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'center';
                        ctx.fillText('Level 1 Complete!', canvas.width / 2, 50);

                        const pacmanSize = PACMAN_RADIUS * 1.5;
                        const ghostSize = GHOST_RADIUS * 1.5;
                        const pacmanX = canvas.width / 2 - 50;

                        const startEyesX = pacmanX + 30;
                        const endEyesX = canvas.width + 100;
                        const currentEyesX = startEyesX + progress * (endEyesX - startEyesX);
                        const currentEyesY = canvas.height / 2 + progress * 50;

                        // Draw Pac-Man (static, already "ate")
                        ctx.fillStyle = 'yellow';
                        ctx.beginPath();
                        ctx.arc(pacmanX, canvas.height / 2, pacmanSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw Blinky's eyes
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(currentEyesX - ghostSize / 2.5, currentEyesY - ghostSize / 3, ghostSize / 4, 0, Math.PI * 2);
                        ctx.arc(currentEyesX + ghostSize / 2.5, currentEyesY - ghostSize / 3, ghostSize / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(currentEyesX - ghostSize / 2.5, currentEyesY - ghostSize / 3, ghostSize / 8, 0, Math.PI * 2);
                        ctx.arc(currentEyesX + ghostSize / 2.5, currentEyesY - ghostSize / 3, ghostSize / 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            ],
        };

        // --- Sound Objects ---
        const sounds = {};

        // --- Utility Functions ---

        /**
         * Displays a custom message box instead of `alert()`.
         * @param {string} message The message to display.
         * @param {function} callback Function to call when "OK" is clicked.
         */
        function showMessageBox(message, callback) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const messageButton = document.getElementById('messageButton');

            messageText.textContent = message;
            messageBox.style.display = 'flex'; // Show the box

            // Remove any previous event listeners to prevent multiple calls
            messageButton.onclick = null;
            messageButton.onclick = () => {
                messageBox.style.display = 'none'; // Hide the box
                if (callback) {
                    callback();
                }
            };
        }

        /**
         * Gets the tile coordinates from pixel coordinates.
         * @param {number} x X-coordinate in pixels.
         * @param {number} y Y-coordinate in pixels.
         * @returns {{row: number, col: number}} Tile coordinates.
         */
        function getTileCoordinates(x, y) {
            return {
                row: Math.floor(y / TILE_SIZE),
                col: Math.floor(x / TILE_SIZE)
            };
        }

        /**
         * Checks if a given tile coordinate is a wall.
         * @param {number} row Row index.
         * @param {number} col Column index.
         * @returns {boolean} True if it's a wall, false otherwise.
         */
        function isWall(row, col) {
            if (row < 0 || row >= gameMap.length || col < 0 || col >= gameMap[0].length) {
                return true; // Out of bounds is a wall
            }
            return gameMap[row][col] === 0;
        }

        /**
         * Checks if a given position (x, y) is colliding with a wall.
         * This checks all four corners of the entity's bounding box.
         * @param {number} x Entity's center X.
         * @param {number} y Entity's center Y.
         * @param {number} radius Entity's radius.
         * @param {number} dx Entity's movement in X.
         * @param {number} dy Entity's movement in Y.
         * @returns {boolean} True if collision with a wall occurs, false otherwise.
         */
        function checkWallCollision(x, y, radius, dx, dy) {
            const newX = x + dx;
            const newY = y + dy;

            // Define corners of the bounding box for collision detection
            const corners = [
                { x: newX - radius, y: newY - radius }, // Top-left
                { x: newX + radius, y: newY - radius }, // Top-right
                { x: newX - radius, y: newY + radius }, // Bottom-left
                { x: newX + radius, y: newY + radius }  // Bottom-right
            ];

            for (const corner of corners) {
                const tile = getTileCoordinates(corner.x, corner.y);
                if (isWall(tile.row, tile.col)) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Centers an entity on a tile.
         * @param {object} entity The entity object (pacman or ghost).
         */
        function centerOnTile(entity) {
            const tileX = Math.floor(entity.x / TILE_SIZE);
            const tileY = Math.floor(entity.y / TILE_SIZE);
            entity.x = tileX * TILE_SIZE + TILE_SIZE / 2;
            entity.y = tileY * TILE_SIZE + TILE_SIZE / 2;
        }

        // --- Drawing Functions ---

        /**
         * Draws the game map (walls, pellets, power pellets).
         */
        function drawMap() {
            for (let row = 0; row < gameMap.length; row++) {
                for (let col = 0; col < gameMap[row].length; col++) {
                    const tileType = gameMap[row][col];
                    const x = col * TILE_SIZE;
                    const y = row * TILE_SIZE;

                    if (tileType === 0) { // Wall
                        ctx.fillStyle = '#0000ff'; // Blue walls
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    } else if (tileType === 2) { // Pellet
                        ctx.fillStyle = '#fff'; // White pellets
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, PELLET_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tileType === 3) { // Power Pellet
                        ctx.fillStyle = '#ffcc00'; // Yellow power pellets
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, POWER_PELLET_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Type 1 (path) and 4 (ghost home) are just empty space
                }
            }
        }

        /**
         * Draws Pac-Man.
         */
        function drawPacman() {
            ctx.fillStyle = pacman.isPoweredUp ? '#ffff00' : '#ffff00'; // Pac-Man color
            ctx.beginPath();
            // Calculate mouth angle
            let startAngle = pacman.angle + pacman.mouthOpen * Math.PI / 4;
            let endAngle = pacman.angle - pacman.mouthOpen * Math.PI / 4;

            ctx.arc(pacman.x, pacman.y, PACMAN_RADIUS, startAngle, endAngle);
            ctx.lineTo(pacman.x, pacman.y);
            ctx.closePath();
            ctx.fill();
        }

        /**
         * Draws Pac-Man's death animation.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {Object} pacman - The Pac-Man object.
         * @param {number} elapsedTime - Time elapsed since animation started (in ms).
         * @param {number} duration - Total duration of the animation (in ms).
         */
        function drawPacmanDeathAnimation(ctx, pacman, elapsedTime, duration) {
            const progress = elapsedTime / duration;
            const scaleFactor = 1 - progress;
            const rotationAngle = progress * Math.PI * 4;

            ctx.save();
            ctx.translate(pacman.x, pacman.y);
            ctx.rotate(rotationAngle);
            ctx.scale(scaleFactor, scaleFactor);

            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(0, 0, PACMAN_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            ctx.restore();
        }

        /**
         * Draws a ghost.
         * @param {object} ghost The ghost object.
         */
        function drawGhost(ctx, ghost) {
            let ghostColor = ghost.color;

            if (ghost.frightened) {
                ghostColor = 'blue';
            } else if (ghost.eaten) {
                ghostColor = 'rgba(0,0,0,0)'; // Transparent body if only eyes are desired
            }

            // Draw ghost body (semicircle top with flat bottom)
            if (!ghost.eaten) {
                ctx.fillStyle = ghostColor;
                ctx.beginPath();
                ctx.arc(ghost.x, ghost.y, GHOST_RADIUS, Math.PI, 0, false); // Top half of circle
                ctx.lineTo(ghost.x - GHOST_RADIUS, ghost.y); // Draw a straight line across to make a flat bottom
                ctx.closePath();
                ctx.fill();
            }

            // Draw Moving Tentacles
            if (!ghost.eaten) {
                const NUM_TENTACLES = 4;
                const TENTACLE_WIDTH = GHOST_RADIUS * 0.4;
                const TENTACLE_HEIGHT = GHOST_RADIUS * 0.6;
                const TENTACLE_WAVE_AMPLITUDE = GHOST_RADIUS / 8;
                const TENTACLE_WAVE_SPEED = 150;
                const basePhase = (Date.now() % TENTACLE_WAVE_SPEED) / TENTACLE_WAVE_SPEED * Math.PI * 2;
                ctx.fillStyle = ghostColor;

                const totalBottomWidth = GHOST_RADIUS * 2;
                const spaceBetweenTentacles = (totalBottomWidth - (NUM_TENTACLES * TENTACLE_WIDTH)) / (NUM_TENTACLES + 1);

                for (let i = 0; i < NUM_TENTACLES; i++) {
                    ctx.beginPath();
                    const tentacleBaseLeftX = ghost.x - GHOST_RADIUS + spaceBetweenTentacles + (i * (TENTACLE_WIDTH + spaceBetweenTentacles));
                    const tentacleBaseRightX = tentacleBaseLeftX + TENTACLE_WIDTH;
                    const tentacleBaseCenterX = tentacleBaseLeftX + TENTACLE_WIDTH / 2;
                    const startY = ghost.y;
                    const waveOffset = Math.sin(basePhase + (i * 1.0)) * TENTACLE_WAVE_AMPLITUDE;
                    ctx.moveTo(tentacleBaseLeftX, startY);
                    ctx.lineTo(tentacleBaseRightX, startY);
                    ctx.lineTo(tentacleBaseCenterX + waveOffset, startY + TENTACLE_HEIGHT);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Default eye/pupil properties
            let pupilOffsetX = 0;
            let pupilOffsetY = 0;
            let currentPupilRadius = GHOST_RADIUS / 8;
            let eyeColor = 'white';
            let pupilColor = 'black';

            if (ghost.frightened) {
                // Frightened State Effects
                pupilOffsetX = 0;
                pupilOffsetY = 0;

                // Pulsating Pupils
                const BASE_PUPIL_RADIUS = GHOST_RADIUS / 8;
                const PULSE_AMPLITUDE = GHOST_RADIUS / 25;
                const PULSE_SPEED = 150;
                const pulsePhase = (Date.now() % PULSE_SPEED) / PULSE_SPEED * Math.PI * 2;
                currentPupilRadius = BASE_PUPIL_RADIUS + Math.sin(pulsePhase) * PULSE_AMPLITUDE;

                // Moving Zig-Zag Mouth
                const MOUTH_WIDTH = GHOST_RADIUS * 1.2;
                const MOUTH_Y_OFFSET = GHOST_RADIUS / 2.5;
                const MOUTH_HEIGHT_AMPLITUDE = GHOST_RADIUS / 5;
                const MOUTH_SPEED = 100;
                const mouthPhase = (Date.now() % MOUTH_SPEED) / MOUTH_SPEED * Math.PI * 2;
                const currentMouthPeakHeight = Math.sin(mouthPhase) * MOUTH_HEIGHT_AMPLITUDE;

                ctx.strokeStyle = 'white';
                ctx.lineWidth = GHOST_RADIUS / 10;
                ctx.beginPath();
                ctx.moveTo(ghost.x - MOUTH_WIDTH / 2, ghost.y + MOUTH_Y_OFFSET);
                ctx.lineTo(ghost.x - MOUTH_WIDTH / 4, ghost.y + MOUTH_Y_OFFSET + currentMouthPeakHeight);
                ctx.lineTo(ghost.x, ghost.y + MOUTH_Y_OFFSET);
                ctx.lineTo(ghost.x + MOUTH_WIDTH / 4, ghost.y + MOUTH_Y_OFFSET + currentMouthPeakHeight);
                ctx.lineTo(ghost.x + MOUTH_WIDTH / 2, ghost.y + MOUTH_Y_OFFSET);
                ctx.stroke();

            } else if (ghost.eaten) {
                // Eaten State Effects (only eyes drawn, body is transparent)
                // Eyes look straight ahead
            } else {
                // Normal State Effects: Eyes look at Pac-Man
                const PUPIL_OFFSET_AMOUNT = GHOST_RADIUS / 5;
                const relativeDx = pacman.x - ghost.x;
                const relativeDy = pacman.y - ghost.y;

                if (Math.abs(relativeDx) > Math.abs(relativeDy)) {
                    if (relativeDx > 0) pupilOffsetX = PUPIL_OFFSET_AMOUNT;
                    else if (relativeDx < 0) pupilOffsetX = -PUPIL_OFFSET_AMOUNT;
                } else {
                    if (relativeDy > 0) pupilOffsetY = PUPIL_OFFSET_AMOUNT;
                    else if (relativeDy < 0) pupilOffsetY = -PUPIL_OFFSET_AMOUNT;
                }
            }

            // Draw Eyes (white)
            ctx.fillStyle = eyeColor;
            ctx.beginPath();
            ctx.arc(ghost.x - GHOST_RADIUS / 2.5, ghost.y - GHOST_RADIUS / 3, GHOST_RADIUS / 4, 0, Math.PI * 2);
            ctx.arc(ghost.x + GHOST_RADIUS / 2.5, ghost.y - GHOST_RADIUS / 3, GHOST_RADIUS / 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw Pupils (black)
            ctx.fillStyle = pupilColor;
            ctx.beginPath();
            ctx.arc(ghost.x - GHOST_RADIUS / 2.5 + pupilOffsetX, ghost.y - GHOST_RADIUS / 3 + pupilOffsetY, currentPupilRadius, 0, Math.PI * 2);
            ctx.arc(ghost.x + GHOST_RADIUS / 2.5 + pupilOffsetX, ghost.y - GHOST_RADIUS / 3 + pupilOffsetY, currentPupilRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Draws the bonus food item on the canvas.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         */
        function drawBonusFood(ctx) {
            if (!bonusFoodActive) return;

            ctx.save();
            ctx.translate(bonusFoodX, bonusFoodY);

            switch (bonusFoodType) {
                case 'cherry':
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(-5, -5, 5, 0, Math.PI * 2); ctx.arc(5, -5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'brown'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-5, -5); ctx.lineTo(-10, -15);
                    ctx.moveTo(5, -5); ctx.lineTo(10, -15); ctx.stroke();
                    break;
                case 'strawberry':
                    ctx.fillStyle = 'crimson';
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'green'; ctx.fillRect(-3, -12, 6, 5);
                    break;
                case 'orange':
                    ctx.fillStyle = 'orange';
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'apple':
                    ctx.fillStyle = 'greenyellow';
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'brown'; ctx.fillRect(-1, -12, 2, 4);
                    break;
                case 'melon':
                    ctx.fillStyle = 'mediumseagreen';
                    ctx.beginPath(); ctx.ellipse(0, 0, 12, 9, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'darkgreen'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.ellipse(0, 0, 10, 7, 0, 0, Math.PI * 2); ctx.stroke();
                    break;
                case 'galaxian':
                    ctx.fillStyle = 'purple';
                    ctx.beginPath();
                    ctx.moveTo(0, -10); ctx.lineTo(8, 0); ctx.lineTo(0, 10); ctx.lineTo(-8, 0);
                    ctx.closePath(); ctx.fill();
                    break;
                case 'bell':
                    ctx.fillStyle = 'gold';
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'gray'; ctx.fillRect(-5, -12, 10, 5);
                    break;
                case 'key':
                    ctx.fillStyle = 'silver';
                    ctx.fillRect(-5, -15, 10, 25);
                    ctx.fillRect(5, 5, 10, 5);
                    ctx.beginPath(); ctx.arc(0, -15, 7, 0, Math.PI * 2); ctx.fill();
                    break;
                default:
                    ctx.fillStyle = 'pink';
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    break;
            }
            ctx.restore();
        }

        /**
         * Draws the score pop-up (e.g., "100") when a bonus item is eaten.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         */
        function drawScorePopup(ctx) {
            if (!scorePopup.active) return;

            const elapsedTime = Date.now() - scorePopup.startTime;
            const alpha = 1 - (elapsedTime / scorePopup.duration);

            if (alpha <= 0) {
                scorePopup.active = false;
                return;
            }

            ctx.save();
            ctx.font = 'bold 20px "Press Start 2P"';
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.textAlign = 'center';
            ctx.fillText(scorePopup.value, scorePopup.x, scorePopup.y - (elapsedTime / 10));
            ctx.restore();
        }

        /**
         * Draws the title screen.
         */
        function drawTitleScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 48px "Press Start 2P"';
            ctx.fillStyle = 'yellow';
            ctx.textAlign = 'center';
            ctx.fillText('PAC-MAN', canvas.width / 2, canvas.height / 2 - 50);

            ctx.font = '24px "Press Start 2P"';
            ctx.fillStyle = 'white';
            ctx.fillText('Press SPACE to Start', canvas.width / 2, canvas.height / 2 + 50);

            ctx.font = '18px "Press Start 2P"';
            ctx.fillStyle = 'gray';
            ctx.fillText('Use Arrow Keys or D-Pad to Move', canvas.width / 2, canvas.height / 2 + 100);
        }

        /**
         * Draws the game over screen.
         */
        function drawGameOverScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 60px "Press Start 2P"';
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);

            ctx.font = '24px "Press Start 2P"';
            ctx.fillStyle = 'white';
            ctx.fillText('Your Score: ' + score, canvas.width / 2, canvas.height / 2 + 30);
            ctx.fillText('Press SPACE to Play Again', canvas.width / 2, canvas.height / 2 + 80);
        }

        /**
         * Draws the current cutscene.
         */
        function drawCutscene() {
            const currentScene = currentCutscene.scenes[currentCutscene.currentSceneIndex];

            if (!currentScene) {
                console.log(`Cutscene '${currentCutscene.id}' finished.`);
                gameState = 'playing';
                resetGame(); // Prepares game for the next level
                return;
            }

            const elapsedTimeInScene = Date.now() - currentCutscene.sceneStartTime;
            const progressInScene = elapsedTimeInScene / currentScene.duration;

            currentScene.draw(ctx, progressInScene);

            if (elapsedTimeInScene >= currentScene.duration) {
                currentCutscene.currentSceneIndex++;
                currentCutscene.sceneStartTime = Date.now();
            }
        }

        // --- Game Logic Functions ---

        /**
         * Updates the score display.
         */
        function updateScoreDisplay() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }

        /**
         * Updates the lives display.
         */
        function updateLivesDisplay() {
            document.getElementById('lives').textContent = `LIVES: ${lives}`;
        }

        /**
         * Resets the positions and states of Pac-Man and ghosts.
         * Called when Pac-Man loses a life.
         */
        function resetEntities() {
            // Reset Pac-Man's state
            pacman.dx = 0;
            pacman.dy = 0;
            pacman.nextDx = 0;
            pacman.nextDy = 0;
            pacman.isPoweredUp = false;
            clearTimeout(pacman.powerUpTimer);
            pacman.mouthOpen = 0;
            pacman.mouthDirection = 1;
            pacman.angle = 0;
            pacman.isDying = false; // Ensure not in dying state

            // Reset ghosts array (re-create to ensure all properties are fresh)
            // This also ensures 'state' is set to 'leavingHouse' for all ghosts.
            ghosts = [
                { id: 'blinky', color: 'red', state: 'leavingHouse' },
                { id: 'pinky', color: 'pink', state: 'leavingHouse' },
                { id: 'inky', color: 'cyan', state: 'leavingHouse' },
                { id: 'clyde', color: 'orange', state: 'leavingHouse' },
                { id: 'sue', color: 'purple', state: 'leavingHouse' }
            ];

            // Assign initial positions to ghosts based on the dynamically generated maze's ghost house
            const blinkyInitialPos = { x: entranceX * TILE_SIZE + TILE_SIZE / 2, y: entranceY * TILE_SIZE + TILE_SIZE / 2 };
            const pinkyInitialPos = { x: (ghostHouseStartCol + 1) * TILE_SIZE + TILE_SIZE / 2, y: (ghostHouseStartRow + 2) * TILE_SIZE + TILE_SIZE / 2 };
            const inkyInitialPos = { x: (ghostHouseStartCol + 3) * TILE_SIZE + TILE_SIZE / 2, y: (ghostHouseStartRow + 2) * TILE_SIZE + TILE_SIZE / 2 };
            const clydeInitialPos = { x: (ghostHouseStartCol + 2) * TILE_SIZE + TILE_SIZE / 2, y: (ghostHouseStartRow + 2) * TILE_SIZE + TILE_SIZE / 2 };
            const sueInitialPos = { x: (ghostHouseStartCol + 2) * TILE_SIZE + TILE_SIZE / 2, y: (ghostHouseStartRow + 3) * TILE_SIZE + TILE_SIZE / 2 };

            ghosts.forEach(ghost => {
                let initialPos;
                if (ghost.id === 'blinky') initialPos = blinkyInitialPos;
                else if (ghost.id === 'pinky') initialPos = pinkyInitialPos;
                else if (ghost.id === 'inky') initialPos = inkyInitialPos;
                else if (ghost.id === 'clyde') initialPos = clydeInitialPos;
                else if (ghost.id === 'sue') initialPos = sueInitialPos;

                Object.assign(ghost, initialPos); // Apply x, y
                ghost.originalX = initialPos.x; // Set original position for returning home
                ghost.originalY = initialPos.y; // Set original position for returning home

                ghost.dx = 0; ghost.dy = 0;
                ghost.frightened = false; ghost.eaten = false;
            });

            // Stop background sirens when entities reset
            stopSound('siren1');
            stopSound('sirenFright');
        }

        /**
         * Generates a new maze using Recursive Backtracker (Depth-First Search).
         * @param {number} logicalWidth - Number of cells wide.
         * @param {number} logicalHeight - Number of cells high.
         * @returns {Array<Array<number>>} The generated maze grid.
         */
        function generateMaze(logicalWidth, logicalHeight) {
            const mapWidth = logicalWidth * 2 + 1;
            const mapHeight = logicalHeight * 2 + 1;

            let newMap = Array(mapHeight).fill(0).map(() => Array(mapWidth).fill(0)); // All walls (0)

            const directions = [
                { dx: 0, dy: -2 }, // Up
                { dx: 0, dy: 2 },  // Down
                { dx: -2, dy: 0 }, // Left
                { dx: 2, dy: 0 }   // Right
            ];

            let stack = [];
            let visited = Array(logicalHeight).fill(false).map(() => Array(logicalWidth).fill(false));

            let startCellX = Math.floor(Math.random() * logicalWidth);
            let startCellY = Math.floor(Math.random() * logicalHeight);

            let currentPhysicalX = startCellX * 2 + 1;
            let currentPhysicalY = startCellY * 2 + 1;

            newMap[currentPhysicalY][currentPhysicalX] = 1; // Mark starting cell as path (1)
            visited[startCellY][startCellX] = true;
            stack.push({ x: startCellX, y: startCellY });

            while (stack.length > 0) {
                let { x: cellX, y: cellY } = stack.pop();

                let unvisitedNeighbors = [];
                for (const dir of directions) {
                    let nextLogicalX = cellX + dir.dx / 2;
                    let nextLogicalY = cellY + dir.dy / 2;

                    if (nextLogicalX >= 0 && nextLogicalX < logicalWidth &&
                        nextLogicalY >= 0 && nextLogicalY < logicalHeight &&
                        !visited[nextLogicalY][nextLogicalX]) {
                        unvisitedNeighbors.push({ dir, nextLogicalX, nextLogicalY });
                    }
                }

                if (unvisitedNeighbors.length > 0) {
                    stack.push({ x: cellX, y: cellY });

                    const { dir, nextLogicalX, nextLogicalY } = unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];

                    let pathWallPhysicalX = cellX * 2 + 1 + dir.dx / 2;
                    let pathWallPhysicalY = cellY * 2 + 1 + dir.dy / 2;
                    let nextPhysicalX = nextLogicalX * 2 + 1;
                    let nextPhysicalY = nextLogicalY * 2 + 1;

                    newMap[pathWallPhysicalY][pathWallPhysicalX] = 1;
                    newMap[nextPhysicalY][nextPhysicalX] = 1;

                    visited[nextLogicalY][nextLogicalX] = true;
                    stack.push({ x: nextLogicalX, y: nextLogicalY });
                }
            }

            // Ensure outer border is walls
            for (let i = 0; i < mapWidth; i++) {
                newMap[0][i] = 0;
                newMap[mapHeight - 1][i] = 0;
            }
            for (let i = 0; i < mapHeight; i++) {
                newMap[i][0] = 0;
                newMap[i][mapWidth - 1] = 0;
            }

            return newMap;
        }

        /**
         * Resets the entire game state, generates a new maze, and starts a new level.
         */
        function resetGame() {
            // Generate a new maze
            gameMap = generateMaze(MAZE_LOGICAL_WIDTH, MAZE_LOGICAL_HEIGHT);

            // Update canvas dimensions based on the new map
            canvas.width = gameMap[0].length * TILE_SIZE;
            canvas.height = gameMap.length * TILE_SIZE;

            // Reset scores and lives for a new game (only if starting from title/game over)
            if (gameState === 'title' || gameState === 'gameOver') {
                score = 0;
                lives = 3;
                level = 1;
            }
            updateScoreDisplay();
            updateLivesDisplay();

            // --- Place Pellets (2) and Power Pellets (3) ---
            let totalPelletsInLevel = 0;
            for (let row = 0; row < gameMap.length; row++) {
                for (let col = 0; col < gameMap[row].length; col++) {
                    if (gameMap[row][col] === 1) { // If it's a path, place a pellet
                        gameMap[row][col] = 2; // Default to pellet
                        totalPelletsInLevel++;
                    }
                }
            }

            // Place Power Pellets strategically (e.g., in corners if they are paths)
            const powerPelletPositions = [
                { row: 1, col: 1 },
                { row: 1, col: gameMap[0].length - 2 },
                { row: gameMap.length - 2, col: 1 },
                { row: gameMap.length - 2, col: gameMap[0].length - 2 }
            ];

            powerPelletPositions.forEach(pos => {
                if (gameMap[pos.row] && gameMap[pos.row][pos.col] === 2) {
                    gameMap[pos.row][pos.col] = 3; // Change to power pellet
                }
            });

            // --- Place Ghost House and Pac-Man Start ---
            // Calculate ghost house position relative to the center of the generated maze
            // This ensures it's always roughly in the middle regardless of maze size
            const GH_WIDTH = 5;
            const GH_HEIGHT = 5;
            ghostHouseStartCol = Math.floor(MAP_WIDTH_TILES / 2) - Math.floor(GH_WIDTH / 2);
            ghostHouseStartRow = Math.floor(MAP_HEIGHT_TILES / 2) - Math.floor(GH_HEIGHT / 2);

            for (let r = 0; r < GH_HEIGHT; r++) {
                for (let c = 0; c < GH_WIDTH; c++) {
                    const currentRow = ghostHouseStartRow + r;
                    const currentCol = ghostHouseStartCol + c;

                    if (currentRow >= 0 && currentRow < gameMap.length &&
                        currentCol >= 0 && currentCol < gameMap[0].length) {
                        if (r === 0 || r === GH_HEIGHT - 1 || c === 0 || c === GH_WIDTH - 1) {
                            gameMap[currentRow][currentCol] = 0; // Outer walls
                        } else {
                            gameMap[currentRow][currentCol] = 4; // Inside ghost home
                        }
                    }
                }
            }
            // Create ghost house entrance (a path directly above the center of the house)
            entranceY = ghostHouseStartRow - 1;
            entranceX = ghostHouseStartCol + Math.floor(GH_WIDTH / 2);
            if (entranceY >= 0 && entranceX >= 0 && entranceX < gameMap[0].length) {
                gameMap[entranceY][entranceX] = 1; // Make it a path/entrance
            } else {
                 // Fallback if entrance is out of bounds (shouldn't happen with typical sizes)
                 console.warn("Ghost house entrance out of map bounds!");
                 entranceY = ghostHouseStartRow + 1; // Try inside the house
                 entranceX = ghostHouseStartCol + Math.floor(GH_WIDTH / 2);
            }

            // Set global pixel coordinates for ghost house exit
            GHOST_HOUSE_EXIT_PIXEL_X = entranceX * TILE_SIZE + TILE_SIZE / 2;
            GHOST_HOUSE_EXIT_PIXEL_Y = entranceY * TILE_SIZE + TILE_SIZE / 2;


            // Adjust Pac-Man initial position
            let pacmanSpawnRow = gameMap.length - 2; // Start from bottom
            let pacmanSpawnCol = Math.floor(gameMap[0].length / 2);
            // Search upwards from the bottom center until a path tile is found
            while (pacmanSpawnRow >= 0 && gameMap[pacmanSpawnRow][pacmanSpawnCol] === 0) {
                pacmanSpawnRow--;
            }
            // Fallback if no path found (unlikely with maze generation)
            if (pacmanSpawnRow < 0) pacmanSpawnRow = gameMap.length - 2;

            pacman.x = pacmanSpawnCol * TILE_SIZE + TILE_SIZE / 2;
            pacman.y = pacmanSpawnRow * TILE_SIZE + TILE_SIZE / 2;

            // Reset entities (Pac-Man and ghosts) to their new starting positions
            resetEntities();

            // --- Dynamically find a suitable bonus food spawn location ---
            let foundBonusSpot = false;
            // Search a central area for a path tile not part of the ghost house
            for (let r = Math.floor(MAP_HEIGHT_TILES / 3); r < Math.floor(MAP_HEIGHT_TILES * 2 / 3); r++) {
                for (let c = Math.floor(MAP_WIDTH_TILES / 3); c < Math.floor(MAP_WIDTH_TILES * 2 / 3); c++) {
                    // Check if it's a path or pellet, and not a ghost house tile
                    if ((gameMap[r][c] === 1 || gameMap[r][c] === 2) && gameMap[r][c] !== 4) {
                        // Ensure it's not too close to the ghost house entrance/center
                        const distToGhostHouseCenter = Math.hypot(c - (ghostHouseStartCol + GH_WIDTH/2), r - (ghostHouseStartRow + GH_HEIGHT/2));
                        if (distToGhostHouseCenter * TILE_SIZE > GHOST_RADIUS * 5) { // Arbitrary distance
                            bonusFoodX = c * TILE_SIZE + TILE_SIZE / 2;
                            bonusFoodY = r * TILE_SIZE + TILE_SIZE / 2;
                            foundBonusSpot = true;
                            break;
                        }
                    }
                }
                if (foundBonusSpot) break;
            }
            // Fallback if no ideal spot found (should be rare with good maze generation)
            if (!foundBonusSpot) {
                bonusFoodX = canvas.width / 2;
                bonusFoodY = canvas.height / 2;
                console.warn("Could not find ideal bonus food spawn spot, defaulting to center.");
            }


            // Reset bonus food related variables for the new level
            bonusFoodActive = false;
            bonusFoodType = '';
            bonusFoodValue = 0;
            bonusFoodDespawnTime = 0;
            pelletsEatenCount = 0;
            bonusFoodSpawnedThisLevel = 0;
            scorePopup.active = false;

            gameState = 'playing'; // Set game state to playing
            gameRunning = true;    // Ensure game logic runs

            // Stop intermission sound if it was playing
            stopSound('intermission');
            // Start the main game siren
            if (!sounds.siren1.playing) { // Only play if not already playing
                playSound('siren1');
                sounds.siren1.playing = true;
            }
        }

        /**
         * Checks if all pellets and power pellets have been eaten.
         * @returns {boolean} True if all edibles are eaten, false otherwise.
         */
        function allPelletsEaten() {
            let remainingPellets = 0;
            for (let row = 0; row < gameMap.length; row++) {
                for (let col = 0; col < gameMap[row].length; col++) {
                    if (gameMap[row][col] === 2 || gameMap[row][col] === 3) {
                        remainingPellets++;
                    }
                }
            }

            if (remainingPellets === 0) {
                level++;
                score += 500; // Bonus for completing level
                updateScoreDisplay();

                stopSound('siren1'); // Stop background sounds
                stopSound('sirenFright');
                playSound('intermission'); // Play intermission sound

                if (cutscenes[`level_${level - 1}_complete`]) {
                    startCutscene(`level_${level - 1}_complete`);
                } else {
                    resetGame(); // No specific cutscene, just go to next level
                }
                return true;
            }
            return false;
        }

        /**
         * Handles Pac-Man's movement.
         */
        function movePacman() {
            // Try to apply next desired direction first
            if (!checkWallCollision(pacman.x, pacman.y, PACMAN_RADIUS, pacman.nextDx * PACMAN_SPEED, pacman.nextDy * PACMAN_SPEED)) {
                pacman.dx = pacman.nextDx;
                pacman.dy = pacman.nextDy;
            }

            // Move Pac-Man if not colliding with a wall in current direction
            if (!checkWallCollision(pacman.x, pacman.y, PACMAN_RADIUS, pacman.dx * PACMAN_SPEED, pacman.dy * PACMAN_SPEED)) {
                pacman.x += pacman.dx * PACMAN_SPEED;
                pacman.y += pacman.dy * PACMAN_SPEED;
            } else {
                // Stop if hitting a wall
                pacman.dx = 0;
                pacman.dy = 0;
                centerOnTile(pacman);
            }

            // Update Pac-Man's angle for drawing
            if (pacman.dx === 1) pacman.angle = 0; // Right
            else if (pacman.dx === -1) pacman.angle = Math.PI; // Left
            else if (pacman.dy === 1) pacman.angle = Math.PI / 2; // Down
            else if (pacman.dy === -1) pacman.angle = -Math.PI / 2; // Up
        }

        /**
         * Updates Pac-Man's mouth animation.
         */
        function updatePacmanMouth() {
            if (pacman.dx !== 0 || pacman.dy !== 0) { // Only animate mouth if moving
                pacman.mouthOpen += pacman.mouthDirection * 0.1;
                if (pacman.mouthOpen > 1 || pacman.mouthOpen < 0) {
                    pacman.mouthDirection *= -1;
                }
            } else { // Keep mouth slightly open when stationary
                pacman.mouthOpen = 0.5;
            }
        }

        /**
         * Handles ghost movement.
         * @param {object} ghost The ghost object.
         */
        function moveGhost(ghost) {
            const currentGhostSpeed = ghost.eaten ? GHOST_SPEED * 2 : GHOST_SPEED; // Eaten ghosts move faster

            // Ghost house exit coordinates (pixel values)
            // GHOST_HOUSE_EXIT_PIXEL_X and Y are set in resetGame()
            const targetExitX = GHOST_HOUSE_EXIT_PIXEL_X;
            const targetExitY = GHOST_HOUSE_EXIT_PIXEL_Y;


            if (ghost.eaten) {
                // Eaten State: Move eyes directly back to original home position, ignoring walls
                let targetX = ghost.originalX;
                let targetY = ghost.originalY;

                ghost.dx = 0;
                ghost.dy = 0;

                // Move towards target X
                if (Math.abs(ghost.x - targetX) > currentGhostSpeed / 2) {
                    ghost.dx = (ghost.x < targetX) ? currentGhostSpeed : -currentGhostSpeed;
                }
                // Move towards target Y
                if (Math.abs(ghost.y - targetY) > currentGhostSpeed / 2) {
                    ghost.dy = (ghost.y < targetY) ? currentGhostSpeed : -currentGhostSpeed;
                }

                // If close enough to home, snap and reset state
                const distanceToHome = Math.hypot(ghost.x - targetX, ghost.y - targetY);
                if (distanceToHome < currentGhostSpeed) {
                    ghost.x = targetX;
                    ghost.y = targetY;
                    ghost.dx = 0; ghost.dy = 0;
                    ghost.frightened = false;
                    ghost.eaten = false;
                    ghost.state = 'leavingHouse'; // Transition to leaving the house
                    console.log(`${ghost.id} returned home and is now preparing to leave.`);
                }
                ghost.x += ghost.dx;
                ghost.y += ghost.dy;

            } else if (ghost.frightened) {
                // Frightened State: Random movement (or flee from Pac-Man)
                const possibleDirections = [
                    { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                    { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
                ];
                possibleDirections.sort(() => Math.random() - 0.5); // Shuffle

                let bestDirection = { dx: 0, dy: 0 };
                let maxDistance = -Infinity;
                let firstValidDirection = null;

                for (const dir of possibleDirections) {
                    if (!checkWallCollision(ghost.x, ghost.y, GHOST_RADIUS, dir.dx * currentGhostSpeed, dir.dy * currentGhostSpeed)) {
                        if (firstValidDirection === null) firstValidDirection = dir;

                        const proposedX = ghost.x + dir.dx * currentGhostSpeed;
                        const proposedY = ghost.y + dir.dy * currentGhostSpeed;
                        const distance = Math.hypot(proposedX - pacman.x, proposedY - pacman.y);

                        if (distance > maxDistance) {
                            maxDistance = distance;
                            bestDirection = dir;
                        }
                    }
                }
                if (bestDirection.dx === 0 && bestDirection.dy === 0 && firstValidDirection !== null) {
                    bestDirection = firstValidDirection;
                }
                ghost.dx = bestDirection.dx;
                ghost.dy = bestDirection.dy;

                if (!checkWallCollision(ghost.x, ghost.y, GHOST_RADIUS, ghost.dx * currentGhostSpeed, ghost.dy * currentGhostSpeed)) {
                    ghost.x += ghost.dx * currentGhostSpeed;
                    ghost.y += ghost.dy * currentGhostSpeed;
                } else {
                    ghost.dx = 0; ghost.dy = 0;
                    centerOnTile(ghost);
                }

            } else if (ghost.state === 'leavingHouse') {
                // Logic for ghosts leaving the house, ignoring walls until at exit
                ghost.dx = 0;
                ghost.dy = 0;

                // Move vertically first to align with exit
                if (Math.abs(ghost.y - targetExitY) > currentGhostSpeed / 2) {
                    ghost.dy = (ghost.y < targetExitY) ? currentGhostSpeed : -currentGhostSpeed;
                }
                // Then move horizontally to align with exit
                else if (Math.abs(ghost.x - targetExitX) > currentGhostSpeed / 2) {
                    ghost.dx = (ghost.x < targetExitX) ? currentGhostSpeed : -currentGhostSpeed;
                }
                // If at exit, snap and change state
                else {
                    ghost.x = targetExitX;
                    ghost.y = targetExitY;
                    ghost.dx = 0; ghost.dy = 0;
                    ghost.state = 'chase'; // Or 'scatter'
                    console.log(`${ghost.id} has left the ghost house.`);
                }
                ghost.x += ghost.dx;
                ghost.y += ghost.dy;

            } else { // 'chase' or 'scatter' states
                // Simple AI: Move towards Pac-Man
                const possibleDirections = [
                    { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                    { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
                ];
                possibleDirections.sort(() => Math.random() - 0.5);

                let bestDirection = { dx: 0, dy: 0 };
                let minDistance = Infinity;
                let firstValidDirection = null;

                for (const dir of possibleDirections) {
                    if (!checkWallCollision(ghost.x, ghost.y, GHOST_RADIUS, dir.dx * currentGhostSpeed, dir.dy * currentGhostSpeed)) {
                        if (firstValidDirection === null) firstValidDirection = dir;

                        const proposedX = ghost.x + dir.dx * currentGhostSpeed;
                        const proposedY = ghost.y + dir.dy * currentGhostSpeed;
                        const distance = Math.hypot(proposedX - pacman.x, proposedY - pacman.y);

                        if (distance < minDistance) {
                            minDistance = distance;
                            bestDirection = dir;
                        }
                    }
                }
                if (bestDirection.dx === 0 && bestDirection.dy === 0 && firstValidDirection !== null) {
                    bestDirection = firstValidDirection;
                }
                ghost.dx = bestDirection.dx;
                ghost.dy = bestDirection.dy;

                if (!checkWallCollision(ghost.x, ghost.y, GHOST_RADIUS, ghost.dx * currentGhostSpeed, ghost.dy * currentGhostSpeed)) {
                    ghost.x += ghost.dx * currentGhostSpeed;
                    ghost.y += ghost.dy * currentGhostSpeed;
                } else {
                    ghost.dx = 0; ghost.dy = 0;
                    centerOnTile(ghost);
                }
            }

            // Keep ghosts centered on tiles if they are aligned
            const currentTileX = Math.floor(ghost.x / TILE_SIZE);
            const currentTileY = Math.floor(ghost.y / TILE_SIZE);
            const tileCenterX = currentTileX * TILE_SIZE + TILE_SIZE / 2;
            const tileCenterY = currentTileY * TILE_SIZE + TILE_SIZE / 2;
            const snapThreshold = currentGhostSpeed * 1.5;

            if (Math.abs(ghost.x - tileCenterX) < snapThreshold && Math.abs(ghost.y - tileCenterY) < snapThreshold) {
                if (ghost.dx !== 0 && Math.abs(ghost.y - tileCenterY) < GHOST_RADIUS / 2) {
                    ghost.y = tileCenterY;
                }
                if (ghost.dy !== 0 && Math.abs(ghost.x - tileCenterX) < GHOST_RADIUS / 2) {
                    ghost.x = tileCenterX;
                }
            }
        }

        /**
         * Checks for collision between Pac-Man and pellets/power pellets.
         */
        function checkPelletAndPowerUpCollision() {
            const { row, col } = getTileCoordinates(pacman.x, pacman.y);
            if (row < 0 || row >= gameMap.length || col < 0 || col >= gameMap[0].length) return; // Out of bounds

            if (gameMap[row][col] === 2) { // Pellet
                gameMap[row][col] = 1; // Mark as empty path
                score += 10;
                updateScoreDisplay();
                pelletsEatenCount++;
                playSound('chomp');

                // Check for bonus food spawn
                if (bonusFoodSpawnedThisLevel < BONUS_FOOD_SPAWN_INTERVALS.length &&
                    pelletsEatenCount === BONUS_FOOD_SPAWN_INTERVALS[bonusFoodSpawnedThisLevel]) {
                    spawnBonusFood();
                    bonusFoodSpawnedThisLevel++;
                }
            } else if (gameMap[row][col] === 3) { // Power Pellet
                gameMap[row][col] = 1; // Mark as empty path
                score += 50;
                updateScoreDisplay();
                activatePowerUp();
                stopSound('siren1'); // Stop regular siren
                playSound('sirenFright'); // Play frightened siren
            }
        }

        /**
         * Activates Pac-Man's power-up state.
         */
        function activatePowerUp() {
            pacman.isPoweredUp = true;
            ghosts.forEach(ghost => {
                if (!ghost.eaten) {
                    ghost.frightened = true;
                    // Reverse ghost direction when frightened
                    ghost.dx *= -1;
                    ghost.dy *= -1;
                }
            });
            clearTimeout(pacman.powerUpTimer);
            pacman.powerUpTimer = setTimeout(() => {
                deactivatePowerUp();
            }, POWER_PELLET_DURATION);
        }

        /**
         * Deactivates Pac-Man's power-up state.
         */
        function deactivatePowerUp() {
            pacman.isPoweredUp = false;
            ghosts.forEach(ghost => ghost.frightened = false);
            stopSound('sirenFright'); // Stop frightened siren
            if (gameState === 'playing' && !ghosts.some(g => g.eaten)) { // Resume regular siren if not in special state
                playSound('siren1');
            }
        }

        /**
         * Checks for collision between Pac-Man and ghosts.
         */
        function checkGhostCollision() {
            ghosts.forEach(ghost => {
                const distance = Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y);
                const collisionThreshold = PACMAN_RADIUS + GHOST_RADIUS - 5;

                if (distance < collisionThreshold) {
                    if (pacman.isPoweredUp && ghost.frightened && !ghost.eaten) {
                        score += 200;
                        updateScoreDisplay();
                        playSound('eatGhost');
                        ghost.eaten = true;
                        ghost.frightened = false;
                        ghost.dx = 0; ghost.dy = 0; // Stop current movement
                    } else if (!ghost.frightened && !ghost.eaten && !pacman.isDying) {
                        // Ghost eats Pac-Man
                        lives--;
                        updateLivesDisplay();
                        pacman.isDying = true;
                        pacman.deathStartTime = Date.now();
                        pacman.dx = 0; pacman.dy = 0; // Stop Pac-Man movement
                        gameRunning = false; // Pause game logic during animation
                        stopSound('siren1'); // Stop background sounds
                        stopSound('sirenFright');
                        playSound('death');
                    }
                }
            });
        }

        /**
         * Selects and activates a bonus food item at its designated location.
         */
        function spawnBonusFood() {
            const bonusIndex = (level - 1) % bonusFoodData.length;
            const chosenBonus = bonusFoodData[bonusIndex];

            bonusFoodType = chosenBonus.type;
            bonusFoodValue = chosenBonus.value;
            // bonusFoodX and bonusFoodY are already set in resetGame()
            bonusFoodActive = true;
            bonusFoodDespawnTime = Date.now() + BONUS_FOOD_DURATION;

            console.log(`Bonus food spawned: ${bonusFoodType} (${bonusFoodValue} pts)`);
            // playSound('fruit'); // This sound is typically played when eaten, not when spawned.
        }

        /**
         * Checks if Pac-Man has collided with the bonus food.
         */
        function checkBonusFoodCollision() {
            if (!bonusFoodActive) return;

            const distance = Math.hypot(pacman.x - bonusFoodX, pacman.y - bonusFoodY);
            const collisionThreshold = PACMAN_RADIUS + (TILE_SIZE / 2 - 5);

            if (distance < collisionThreshold) {
                score += bonusFoodValue;
                updateScoreDisplay();
                console.log(`Pac-Man ate ${bonusFoodType} for ${bonusFoodValue} points!`);

                scorePopup.active = true;
                scorePopup.x = bonusFoodX;
                scorePopup.y = bonusFoodY;
                scorePopup.value = bonusFoodValue;
                scorePopup.startTime = Date.now();

                bonusFoodActive = false;
                playSound('fruit'); // Play fruit eaten sound
            }
        }

        // --- Sound Management Functions ---
        function loadSounds() {
            sounds.chompPool = [];
            const CHOMP_POOL_SIZE = 5;
            for (let i = 0; i < CHOMP_POOL_SIZE; i++) {
                const audio = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_chomp.wav');
                audio.volume = 0.5;
                sounds.chompPool.push(audio);
            }
            sounds.currentChompIndex = 0;

            sounds.beginning = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_beginning.wav');
            sounds.beginning.volume = 0.7;
            sounds.beginning.played = false; // Custom flag to play once

            sounds.death = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_death.wav');
            sounds.death.volume = 0.8;
            sounds.death.playing = false; // Custom flag to track if death sound is playing

            sounds.eatGhost = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_eatghost.wav');
            sounds.eatGhost.volume = 0.8;

            sounds.fruit = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_eatfruit.wav');
            sounds.fruit.volume = 0.8;

            sounds.siren1 = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_siren1.wav');
            sounds.siren1.loop = true;
            sounds.siren1.volume = 0.4;
            sounds.siren1.playing = false; // Custom flag for looping background sound

            sounds.sirenFright = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_siren_fright.wav');
            sounds.sirenFright.loop = true;
            sounds.sirenFright.volume = 0.4;
            sounds.sirenFright.playing = false;

            sounds.intermission = new Audio('https://cdn.jsdelivr.net/gh/google/generative-ai-docs/site/en/docs/gemini/tutorials/web_audio_game/assets/pacman_intermission.wav');
            sounds.intermission.volume = 0.6;

            console.log("Sounds loaded.");
        }

        function playSound(soundName) {
            if (soundName === 'chomp') {
                const audio = sounds.chompPool[sounds.currentChompIndex];
                audio.currentTime = 0;
                audio.play().catch(e => console.error("Chomp audio play error:", e));
                sounds.currentChompIndex = (sounds.currentChompIndex + 1) % sounds.chompPool.length;
            } else {
                const audio = sounds[soundName];
                if (audio) {
                    audio.currentTime = 0;
                    audio.play().catch(e => console.error(`Audio play error for ${soundName}:`, e));
                } else {
                    console.warn(`Sound '${soundName}' not found.`);
                }
            }
        }

        function stopSound(soundName) {
            const audio = sounds[soundName];
            if (audio) { // Check if audio object exists
                audio.pause();
                audio.currentTime = 0;
                // Reset custom playing flags if they exist
                if (soundName === 'siren1' || soundName === 'sirenFright' || soundName === 'death' || soundName === 'beginning') {
                    sounds[soundName].playing = false;
                    if (soundName === 'beginning') sounds.beginning.played = false; // Reset played flag for beginning sound
                }
            }
        }

        function startCutscene(cutsceneId) {
            if (cutscenes[cutsceneId]) {
                gameState = 'cutscene';
                currentCutscene.id = cutsceneId;
                currentCutscene.scenes = cutscenes[cutsceneId];
                currentCutscene.currentSceneIndex = 0;
                currentCutscene.sceneStartTime = Date.now();
                gameRunning = false; // Pause all normal game updates

                pacman.dx = 0; pacman.dy = 0;
                ghosts.forEach(g => { g.dx = 0; g.dy = 0; });
            } else {
                console.warn(`Cutscene with ID '${cutsceneId}' not found. Skipping.`);
                gameState = 'playing';
                resetGame();
            }
        }

        // --- Main Game Loop ---
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'title') {
                drawTitleScreen();
            } else if (gameState === 'playing') {
                drawMap();

                // Manage background siren based on ghost state
                const anyGhostFrightenedOrEaten = ghosts.some(g => g.frightened || g.eaten);
                if (!anyGhostFrightenedOrEaten) {
                    if (!sounds.siren1.playing) {
                        stopSound('sirenFright'); // Ensure frightened siren is off
                        playSound('siren1');
                        sounds.siren1.playing = true;
                    }
                } else {
                    if (sounds.siren1.playing) {
                        stopSound('siren1');
                        sounds.siren1.playing = false;
                    }
                }


                if (pacman.isDying) {
                    const elapsedTime = Date.now() - pacman.deathStartTime;
                    if (elapsedTime < DEATH_ANIMATION_DURATION) {
                        drawPacmanDeathAnimation(ctx, pacman, elapsedTime, DEATH_ANIMATION_DURATION);
                    } else {
                        pacman.isDying = false;
                        sounds.death.playing = false; // Reset death sound flag
                        if (lives <= 0) {
                            gameState = 'gameOver';
                            stopSound('siren1');
                            stopSound('sirenFright');
                            return;
                        } else {
                            resetGame(); // Resets entities, map, and restarts sirens
                        }
                    }
                } else {
                    movePacman();
                    updatePacmanMouth();
                    checkPelletAndPowerUpCollision();
                    checkGhostCollision();
                    checkBonusFoodCollision(); // Check for bonus food collision

                    if (bonusFoodActive) {
                        if (Date.now() > bonusFoodDespawnTime) {
                            bonusFoodActive = false;
                            console.log("Bonus food disappeared due to timeout.");
                        } else {
                            drawBonusFood(ctx);
                        }
                    }

                    if (allPelletsEaten()) {
                        return;
                    }

                    drawPacman(ctx, pacman);
                    ghosts.forEach(ghost => drawGhost(ctx, ghost));
                }
            } else if (gameState === 'gameOver') {
                drawGameOverScreen();
                // Ensure sounds are stopped on game over
                stopSound('siren1');
                stopSound('sirenFright');
                stopSound('intermission');
            } else if (gameState === 'cutscene') {
                drawCutscene();
            }

            drawScorePopup(ctx); // Always draw score pop-up if active

            if (gameState === 'playing' || gameState === 'title' || gameState === 'gameOver' || gameState === 'cutscene' || pacman.isDying) {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // --- Event Listeners ---

        // Keyboard input for Pac-Man movement and game start/restart
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') { // Handle space bar for starting/restarting
                if (gameState === 'title') {
                    if (!sounds.beginning.played) { // Play intro sound only once when starting from title
                        playSound('beginning');
                        sounds.beginning.played = true;
                    }
                    resetGame(); // This will set gameState to 'playing'
                } else if (gameState === 'gameOver') {
                    if (sounds.beginning) sounds.beginning.played = false; // Allow intro sound to play again if restarting
                    resetGame(); // This will set gameState to 'playing'
                }
                return; // Don't process movement keys if starting/restarting
            }

            if (gameState !== 'playing') return; // Only allow movement keys when playing

            switch (e.key) {
                case 'ArrowUp':
                    pacman.nextDx = 0;
                    pacman.nextDy = -1;
                    break;
                case 'ArrowDown':
                    pacman.nextDx = 0;
                    pacman.nextDy = 1;
                    break;
                case 'ArrowLeft':
                    pacman.nextDx = -1;
                    pacman.nextDy = 0;
                    break;
                case 'ArrowRight':
                    pacman.nextDx = 1;
                    pacman.nextDy = 0;
                    break;
            }
        });

        // Touch/Click input for D-pad buttons
        document.getElementById('upButton').addEventListener('click', () => {
            if (gameState !== 'playing') return;
            pacman.nextDx = 0; pacman.nextDy = -1;
        });
        document.getElementById('downButton').addEventListener('click', () => {
            if (gameState !== 'playing') return;
            pacman.nextDx = 0; pacman.nextDy = 1;
        });
        document.getElementById('leftButton').addEventListener('click', () => {
            if (gameState !== 'playing') return;
            pacman.nextDx = -1; pacman.nextDy = 0;
        });
        document.getElementById('rightButton').addEventListener('click', () => {
            if (gameState !== 'playing') return;
            pacman.nextDx = 1; pacman.nextDy = 0;
        });

        // Initial setup and start game
        window.onload = function() {
            loadSounds(); // Load all audio files
            // Initial call to gameLoop, which will draw the title screen first
            requestAnimationFrame(gameLoop);
        };
    </script>
</body>
</html>